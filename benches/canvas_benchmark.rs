use criterion::{black_box, criterion_group, criterion_main, Criterion};
use termplot_rs::canvas::{BrailleCanvas, ColorBlend};
use colored::Color;

fn draw_primitives_bench(c: &mut Criterion) {
    let mut group = c.benchmark_group("Dibujo de Primitivas");
    
    // Un lienzo estándar de tamaño de terminal grande (100x50 caracteres -> 200x200 píxeles)
    let mut canvas = BrailleCanvas::new(100, 50);

    group.bench_function("1000 Lineas (Con Clipping)", |b| {
        b.iter(|| {
            // Limpiamos rápido para no saturar el test
            canvas.clear();
            // Dibujamos 1000 líneas aleatorias que cruzan y se salen de la pantalla
            for i in 0..1000 {
                let offset = (i % 300) as isize - 50; // Para que muchas salgan fuera y actúe el clipping
                canvas.line_screen(offset, -offset, 200 - offset, 200 + offset, Some(Color::Green));
            }
            // Evita que el compilador optimice y elimine el bucle
            black_box(&canvas);
        })
    });

    group.bench_function("100 Circulos Rellenos", |b| {
        b.iter(|| {
            canvas.clear();
            for i in 0..100 {
                let pos = (i * 2) as isize;
                canvas.circle_filled(pos, pos, 15, Some(Color::Red));
            }
            black_box(&canvas);
        })
    });

    group.finish();
}

fn render_loop_bench(c: &mut Criterion) {
    let mut group = c.benchmark_group("Renderizado (String vs Zero-Allocation)");
    
    // Lienzo de 120x40 caracteres (típico juego a pantalla completa)
    let mut canvas = BrailleCanvas::new(120, 40);
    
    // Llenamos el lienzo con "ruido" para que el renderizador tenga trabajo real procesando colores y máscaras
    for y in 0..canvas.pixel_height() {
        for x in 0..canvas.pixel_width() {
            if (x + y) % 3 == 0 {
                let color = if x % 2 == 0 { Some(Color::Cyan) } else { None };
                canvas.set_pixel_screen(x, y, color);
            }
        }
    }

    // 1. El método tradicional: crea un String nuevo cada vez (lento por el recolector/allocator)
    group.bench_function("render() - Asignacion Dinamica", |b| {
        b.iter(|| {
            let output = canvas.render();
            black_box(output);
        })
    });

    // 2. El método PRO: reutiliza el mismo buffer String (Zero-Allocation)
    let mut reusable_buffer = String::with_capacity(120 * 40 * 15);
    group.bench_function("render_to() - Zero-Allocation", |b| {
        b.iter(|| {
            reusable_buffer.clear(); // Vaciamos, pero la memoria sigue asignada
            canvas.render_to(&mut reusable_buffer, true, Some("Benchmark")).unwrap();
            black_box(&reusable_buffer);
        })
    });

    group.finish();
}

// Registramos los grupos y ejecutamos
criterion_group!(benches, draw_primitives_bench, render_loop_bench);
criterion_main!(benches);
